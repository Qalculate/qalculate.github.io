<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libqalculate-4.3.0: Prefix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libqalculate-4.3.0
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classPrefix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Prefix Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Abstract class for prefixes.  
 <a href="classPrefix.html#details">More...</a></p>

<p><code>#include &lt;Prefix.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Prefix:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPrefix.png" usemap="#Prefix_map" alt=""/>
  <map id="Prefix_map" name="Prefix_map">
<area href="classBinaryPrefix.html" title="A binary prefix." alt="BinaryPrefix" shape="rect" coords="0,56,90,80"/>
<area href="classDecimalPrefix.html" title="A decimal (metric) prefix." alt="DecimalPrefix" shape="rect" coords="100,56,190,80"/>
<area href="classNumberPrefix.html" title="A prefix with a free numerical value." alt="NumberPrefix" shape="rect" coords="200,56,290,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9a210fa8118aab43647bdc884df637b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a9a210fa8118aab43647bdc884df637b4">Prefix</a> (std::string long_name, std::string short_name=&quot;&quot;, std::string unicode_name=&quot;&quot;)</td></tr>
<tr class="separator:a9a210fa8118aab43647bdc884df637b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada42847734fb1c0d0312b8f0b6c32e64"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#ada42847734fb1c0d0312b8f0b6c32e64">shortName</a> (bool return_long_if_no_short=true, bool use_unicode=false) const</td></tr>
<tr class="separator:ada42847734fb1c0d0312b8f0b6c32e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444a10058f6510e776aa9632a32f3398"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a444a10058f6510e776aa9632a32f3398">longName</a> (bool return_short_if_no_long=true, bool use_unicode=false) const</td></tr>
<tr class="separator:a444a10058f6510e776aa9632a32f3398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa5234ff4a76ff19be3ca199607faba"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a5fa5234ff4a76ff19be3ca199607faba">unicodeName</a> (bool return_short_if_no_uni=true) const</td></tr>
<tr class="separator:a5fa5234ff4a76ff19be3ca199607faba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2a426743e557ade1b5e5b4075ab32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a0b2a426743e557ade1b5e5b4075ab32f">setShortName</a> (std::string short_name)</td></tr>
<tr class="separator:a0b2a426743e557ade1b5e5b4075ab32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad295c2a637325b567b493c76350df2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#ad295c2a637325b567b493c76350df2ba">setLongName</a> (std::string long_name)</td></tr>
<tr class="separator:ad295c2a637325b567b493c76350df2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9175b18d4bdd3943d1dcbbfb2fa0be48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a9175b18d4bdd3943d1dcbbfb2fa0be48">setUnicodeName</a> (std::string unicode_name)</td></tr>
<tr class="separator:a9175b18d4bdd3943d1dcbbfb2fa0be48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2c315b68499d51d0e531d52c9235f4"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#adf2c315b68499d51d0e531d52c9235f4">name</a> (bool short_default=true, bool use_unicode=false, bool(*can_display_unicode_string_function)(const char *, void *)=NULL, void *can_display_unicode_string_arg=NULL) const</td></tr>
<tr class="separator:adf2c315b68499d51d0e531d52c9235f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d2eea29f1fd91acab220c435085c3b"><td class="memItemLeft" align="right" valign="top"><a id="af0d2eea29f1fd91acab220c435085c3b" name="af0d2eea29f1fd91acab220c435085c3b"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>referenceName</b> () const</td></tr>
<tr class="separator:af0d2eea29f1fd91acab220c435085c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5c7ceb15ba8a8f2fa19e8d03d274bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#aeb5c7ceb15ba8a8f2fa19e8d03d274bf">preferredName</a> (bool abbreviation=false, bool use_unicode=false, bool plural=false, bool reference=false, bool(*can_display_unicode_string_function)(const char *, void *)=NULL, void *can_display_unicode_string_arg=NULL) const</td></tr>
<tr class="separator:aeb5c7ceb15ba8a8f2fa19e8d03d274bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dba8f4790b49aedb35d96d35e211200"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a9dba8f4790b49aedb35d96d35e211200">preferredInputName</a> (bool abbreviation=false, bool use_unicode=false, bool plural=false, bool reference=false, bool(*can_display_unicode_string_function)(const char *, void *)=NULL, void *can_display_unicode_string_arg=NULL) const</td></tr>
<tr class="separator:a9dba8f4790b49aedb35d96d35e211200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1177479f9812d7961dc7291f7a6dcf25"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a1177479f9812d7961dc7291f7a6dcf25">preferredDisplayName</a> (bool abbreviation=false, bool use_unicode=false, bool plural=false, bool reference=false, bool(*can_display_unicode_string_function)(const char *, void *)=NULL, void *can_display_unicode_string_arg=NULL) const</td></tr>
<tr class="separator:a1177479f9812d7961dc7291f7a6dcf25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff955620187478c8da85dc38fd8f879"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a5ff955620187478c8da85dc38fd8f879">getName</a> (size_t index) const</td></tr>
<tr class="separator:a5ff955620187478c8da85dc38fd8f879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebd140b5f6b28be7a792dd4e186cc6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a8ebd140b5f6b28be7a792dd4e186cc6a">setName</a> (const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;ename, size_t index=1)</td></tr>
<tr class="separator:a8ebd140b5f6b28be7a792dd4e186cc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9bb8a40435b7ac6436d79a44e6dbd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#acf9bb8a40435b7ac6436d79a44e6dbd5">setName</a> (std::string sname, size_t index)</td></tr>
<tr class="separator:acf9bb8a40435b7ac6436d79a44e6dbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e24cfcafa49b234d2e7d8f5552cda8"><td class="memItemLeft" align="right" valign="top"><a id="ab9e24cfcafa49b234d2e7d8f5552cda8" name="ab9e24cfcafa49b234d2e7d8f5552cda8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addName</b> (const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;ename, size_t index=0)</td></tr>
<tr class="separator:ab9e24cfcafa49b234d2e7d8f5552cda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a108724db07161ed629a9aaf2893fc"><td class="memItemLeft" align="right" valign="top"><a id="a56a108724db07161ed629a9aaf2893fc" name="a56a108724db07161ed629a9aaf2893fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addName</b> (std::string sname, size_t index=0)</td></tr>
<tr class="separator:a56a108724db07161ed629a9aaf2893fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bda5e71aa4aea5f9f13324089ead98"><td class="memItemLeft" align="right" valign="top"><a id="a29bda5e71aa4aea5f9f13324089ead98" name="a29bda5e71aa4aea5f9f13324089ead98"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>countNames</b> () const</td></tr>
<tr class="separator:a29bda5e71aa4aea5f9f13324089ead98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4511fae2888a172386e3364f9ac495a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a4511fae2888a172386e3364f9ac495a2">clearNames</a> ()</td></tr>
<tr class="separator:a4511fae2888a172386e3364f9ac495a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74166591ff1ab3e4c87a832f672ed22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#ab74166591ff1ab3e4c87a832f672ed22">clearNonReferenceNames</a> ()</td></tr>
<tr class="separator:ab74166591ff1ab3e4c87a832f672ed22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd97084c2c8535cdb62fff3e4c2098f9"><td class="memItemLeft" align="right" valign="top"><a id="afd97084c2c8535cdb62fff3e4c2098f9" name="afd97084c2c8535cdb62fff3e4c2098f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeName</b> (size_t index)</td></tr>
<tr class="separator:afd97084c2c8535cdb62fff3e4c2098f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82bd3fe93f63840b9669d7fe1f09156"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#aa82bd3fe93f63840b9669d7fe1f09156">hasName</a> (const std::string &amp;sname, bool case_sensitive=true) const</td></tr>
<tr class="separator:aa82bd3fe93f63840b9669d7fe1f09156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accef0ff56e2748a97bd72792c663bf9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#accef0ff56e2748a97bd72792c663bf9f">hasNameCaseSensitive</a> (const std::string &amp;sname) const</td></tr>
<tr class="separator:accef0ff56e2748a97bd72792c663bf9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202e65581551565439ae51715b6d5562"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a202e65581551565439ae51715b6d5562">findName</a> (int abbreviation=-1, int use_unicode=-1, int plural=-1, bool(*can_display_unicode_string_function)(const char *, void *)=NULL, void *can_display_unicode_string_arg=NULL) const</td></tr>
<tr class="separator:a202e65581551565439ae51715b6d5562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae828e66c2fc5b58cc6cc6df5db15d2b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNumber.html">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#ae828e66c2fc5b58cc6cc6df5db15d2b2">value</a> (const <a class="el" href="classNumber.html">Number</a> &amp;nexp) const =0</td></tr>
<tr class="separator:ae828e66c2fc5b58cc6cc6df5db15d2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eec8b3ac6266f3865d169c07d9e26d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNumber.html">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#aa1eec8b3ac6266f3865d169c07d9e26d">value</a> (int iexp) const =0</td></tr>
<tr class="separator:aa1eec8b3ac6266f3865d169c07d9e26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae304214d9254a1e9e06d8ee2c6df09ab"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classNumber.html">Number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#ae304214d9254a1e9e06d8ee2c6df09ab">value</a> () const =0</td></tr>
<tr class="separator:ae304214d9254a1e9e06d8ee2c6df09ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3d9095de33a874a898b7218636be3a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPrefix.html#a2e3d9095de33a874a898b7218636be3a">type</a> () const =0</td></tr>
<tr class="separator:a2e3d9095de33a874a898b7218636be3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adb3936ef9487c121e66c0fd451dba029"><td class="memItemLeft" align="right" valign="top"><a id="adb3936ef9487c121e66c0fd451dba029" name="adb3936ef9487c121e66c0fd451dba029"></a>
std::vector&lt; <a class="el" href="structExpressionName.html">ExpressionName</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>names</b></td></tr>
<tr class="separator:adb3936ef9487c121e66c0fd451dba029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Abstract class for prefixes. </p>
<p >A prefix is prepended to a unit to specify a quantity multiplicator. A prefix has a numerical value which raised to the units power defines the quantity. In for example the expression "3 kilometers", meter is the unit, 3 is regular quantity, and kilo is a prefix with a value 1000, thus the example equals "3000 meters". If the unit instead had been squared, the value of the prefix would have been raised by two and the total quantity would have been 3.000.000.</p>
<p >Prefixes can have up to free different three names &ndash; a long name, a short name and a short unicode name. The unicode name is an alternative to the short name that is preferred if unicode characters can be displayed. The names or used to reference the prefix in mathematical expressions and to display a prefix in a result. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9a210fa8118aab43647bdc884df637b4" name="a9a210fa8118aab43647bdc884df637b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a210fa8118aab43647bdc884df637b4">&#9670;&nbsp;</a></span>Prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Prefix::Prefix </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>long_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>short_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>unicode_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">long_name</td><td>Long name. </td></tr>
    <tr><td class="paramname">short_name</td><td>Short name. </td></tr>
    <tr><td class="paramname">unicode_name</td><td>Unicode name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4511fae2888a172386e3364f9ac495a2" name="a4511fae2888a172386e3364f9ac495a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4511fae2888a172386e3364f9ac495a2">&#9670;&nbsp;</a></span>clearNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Prefix::clearNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes all names. </p>

</div>
</div>
<a id="ab74166591ff1ab3e4c87a832f672ed22" name="ab74166591ff1ab3e4c87a832f672ed22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74166591ff1ab3e4c87a832f672ed22">&#9670;&nbsp;</a></span>clearNonReferenceNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Prefix::clearNonReferenceNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Removes all names that are not used for reference (<a class="el" href="structExpressionName.html#a89af7d9b82d81e819144e162053fe3f6" title="If the name shall be used as a fixed reference. If this is set to true, the name will kept as it is i...">ExpressionName.reference</a> = true). </p>

</div>
</div>
<a id="a202e65581551565439ae51715b6d5562" name="a202e65581551565439ae51715b6d5562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202e65581551565439ae51715b6d5562">&#9670;&nbsp;</a></span>findName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp; Prefix::findName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>abbreviation</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>use_unicode</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plural</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const char *, void *)&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_function</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Searches for a name with specific properties.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abbreviation</td><td>If the name must be abbreviated. 1=true, 0=false, -1=ignore. </td></tr>
    <tr><td class="paramname">use_unicode</td><td>If the name must have unicode characters. 1=true, 0=false, -1=ignore. </td></tr>
    <tr><td class="paramname">plural</td><td>If the name must be in plural form. 1=true, 0=false, -1=ignore. </td></tr>
    <tr><td class="paramname">can_display_unicode_string_function</td><td>Function that tests if the unicode characters in a name can be displayed. If the function returns false, the name will be rejected. </td></tr>
    <tr><td class="paramname">can_display_unicode_string_arg</td><td><a class="el" href="classArgument.html" title="A mathematical function argument definition with free value and base class for all argument definitio...">Argument</a> to pass to the above test function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first found name with the specified properties or empty_expression_name if none found. </dd></dl>

</div>
</div>
<a id="a5ff955620187478c8da85dc38fd8f879" name="a5ff955620187478c8da85dc38fd8f879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff955620187478c8da85dc38fd8f879">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp; Prefix::getName </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns name for an index (starting at one). All functions can be traversed by starting at index one and increasing the index until empty_expression_name is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index of name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Name for index or empty_expression_name if not found. </dd></dl>

</div>
</div>
<a id="aa82bd3fe93f63840b9669d7fe1f09156" name="aa82bd3fe93f63840b9669d7fe1f09156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82bd3fe93f63840b9669d7fe1f09156">&#9670;&nbsp;</a></span>hasName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Prefix::hasName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>case_sensitive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the prefix has a name with a specific text string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sname</td><td>A text string to look for (not case sensitive) </td></tr>
    <tr><td class="paramname">case_sensitive</td><td>If the name is case sensitive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the name with the given text string or zero if such a name was not found. </dd></dl>

</div>
</div>
<a id="accef0ff56e2748a97bd72792c663bf9f" name="accef0ff56e2748a97bd72792c663bf9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accef0ff56e2748a97bd72792c663bf9f">&#9670;&nbsp;</a></span>hasNameCaseSensitive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Prefix::hasNameCaseSensitive </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Checks if the prefix has a name with a specific case sensitive text string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sname</td><td>A text string to look for (case sensitive) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the name with the given text string or zero if such a name was not found. </dd></dl>

</div>
</div>
<a id="a444a10058f6510e776aa9632a32f3398" name="a444a10058f6510e776aa9632a32f3398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444a10058f6510e776aa9632a32f3398">&#9670;&nbsp;</a></span>longName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Prefix::longName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_short_if_no_long</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_unicode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the long name of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return_short_if_no_long</td><td>If the short name shall be returned if the prefix has not got a long name (if it is empty). </td></tr>
    <tr><td class="paramname">use_unicode</td><td>If a unicode version of the name is allowed and preferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The long name of the prefix. </dd></dl>

</div>
</div>
<a id="adf2c315b68499d51d0e531d52c9235f4" name="adf2c315b68499d51d0e531d52c9235f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2c315b68499d51d0e531d52c9235f4">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Prefix::name </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>short_default</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_unicode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const char *, void *)&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_function</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns a preferred name of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">short_default</td><td>If a short name is preferred. </td></tr>
    <tr><td class="paramname">use_unicode</td><td>If a unicode name is preferred. </td></tr>
    <tr><td class="paramname">can_display_unicode_string_function</td><td>Function that tests if the unicode characters in a name can be displayed. If the function returns false, the name will be rejected. </td></tr>
    <tr><td class="paramname">can_display_unicode_string_arg</td><td><a class="el" href="classArgument.html" title="A mathematical function argument definition with free value and base class for all argument definitio...">Argument</a> to pass to the above test function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A preferred name. </dd></dl>

</div>
</div>
<a id="a1177479f9812d7961dc7291f7a6dcf25" name="a1177479f9812d7961dc7291f7a6dcf25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1177479f9812d7961dc7291f7a6dcf25">&#9670;&nbsp;</a></span>preferredDisplayName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp; Prefix::preferredDisplayName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abbreviation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_unicode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>plural</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reference</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const char *, void *)&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_function</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the name that best fulfils provided criterias and is suitable for display. If two names are equally preferred, the one with lowest index is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abbreviation</td><td>If an abbreviated name is preferred. </td></tr>
    <tr><td class="paramname">use_unicode</td><td>If a name with unicode characters can be displayed/is preferred (prioritized if false). </td></tr>
    <tr><td class="paramname">can_display_unicode_string_function</td><td>Function that tests if the unicode characters in a name can be displayed. If the function returns false, the name will be rejected. </td></tr>
    <tr><td class="paramname">can_display_unicode_string_arg</td><td><a class="el" href="classArgument.html" title="A mathematical function argument definition with free value and base class for all argument definitio...">Argument</a> to pass to the above test function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The preferred name. </dd></dl>

</div>
</div>
<a id="a9dba8f4790b49aedb35d96d35e211200" name="a9dba8f4790b49aedb35d96d35e211200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dba8f4790b49aedb35d96d35e211200">&#9670;&nbsp;</a></span>preferredInputName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp; Prefix::preferredInputName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abbreviation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_unicode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>plural</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reference</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const char *, void *)&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_function</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the name that best fulfils provided criterias and is suitable for user input. If two names are equally preferred, the one with lowest index is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abbreviation</td><td>If an abbreviated name is preferred. </td></tr>
    <tr><td class="paramname">use_unicode</td><td>If a name with unicode characters can be displayed/is preferred (prioritized if false). </td></tr>
    <tr><td class="paramname">plural</td><td>If a name in plural form is preferred. </td></tr>
    <tr><td class="paramname">reference</td><td>If a reference name is preferred (ignored if false). </td></tr>
    <tr><td class="paramname">can_display_unicode_string_function</td><td>Function that tests if the unicode characters in a name can be displayed. If the function returns false, the name will be rejected. </td></tr>
    <tr><td class="paramname">can_display_unicode_string_arg</td><td><a class="el" href="classArgument.html" title="A mathematical function argument definition with free value and base class for all argument definitio...">Argument</a> to pass to the above test function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The preferred name. </dd></dl>

</div>
</div>
<a id="aeb5c7ceb15ba8a8f2fa19e8d03d274bf" name="aeb5c7ceb15ba8a8f2fa19e8d03d274bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5c7ceb15ba8a8f2fa19e8d03d274bf">&#9670;&nbsp;</a></span>preferredName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp; Prefix::preferredName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>abbreviation</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_unicode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>plural</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reference</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(const char *, void *)&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_function</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>can_display_unicode_string_arg</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the name that best fulfils provided criterias. If two names are equally preferred, the one with lowest index is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">abbreviation</td><td>If an abbreviated name is preferred. </td></tr>
    <tr><td class="paramname">use_unicode</td><td>If a name with unicode characters can be displayed/is preferred (prioritized if false). </td></tr>
    <tr><td class="paramname">plural</td><td>If a name in plural form is preferred. </td></tr>
    <tr><td class="paramname">reference</td><td>If a reference name is preferred (ignored if false). </td></tr>
    <tr><td class="paramname">can_display_unicode_string_function</td><td>Function that tests if the unicode characters in a name can be displayed. If the function returns false, the name will be rejected. </td></tr>
    <tr><td class="paramname">can_display_unicode_string_arg</td><td><a class="el" href="classArgument.html" title="A mathematical function argument definition with free value and base class for all argument definitio...">Argument</a> to pass to the above test function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The preferred name. </dd></dl>

</div>
</div>
<a id="ad295c2a637325b567b493c76350df2ba" name="ad295c2a637325b567b493c76350df2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad295c2a637325b567b493c76350df2ba">&#9670;&nbsp;</a></span>setLongName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Prefix::setLongName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>long_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the long name of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">long_name</td><td>The new long name for the prefix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ebd140b5f6b28be7a792dd4e186cc6a" name="a8ebd140b5f6b28be7a792dd4e186cc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ebd140b5f6b28be7a792dd4e186cc6a">&#9670;&nbsp;</a></span>setName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Prefix::setName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structExpressionName.html">ExpressionName</a> &amp;&#160;</td>
          <td class="paramname"><em>ename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Changes a name. If a name for the provided index is not present, it is added (equivalent to addName(ename, index)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ename</td><td>The new name. </td></tr>
    <tr><td class="paramname">index</td><td>Index of name to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf9bb8a40435b7ac6436d79a44e6dbd5" name="acf9bb8a40435b7ac6436d79a44e6dbd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9bb8a40435b7ac6436d79a44e6dbd5">&#9670;&nbsp;</a></span>setName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Prefix::setName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>sname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Changes the text string of a name. If a name for the provided index is not present, it is added (equivalent to addName(sname, index)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sname</td><td>The new name text string. </td></tr>
    <tr><td class="paramname">index</td><td>Index of name to change. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b2a426743e557ade1b5e5b4075ab32f" name="a0b2a426743e557ade1b5e5b4075ab32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b2a426743e557ade1b5e5b4075ab32f">&#9670;&nbsp;</a></span>setShortName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Prefix::setShortName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>short_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the short name of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">short_name</td><td>The new short name for the prefix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9175b18d4bdd3943d1dcbbfb2fa0be48" name="a9175b18d4bdd3943d1dcbbfb2fa0be48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9175b18d4bdd3943d1dcbbfb2fa0be48">&#9670;&nbsp;</a></span>setUnicodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Prefix::setUnicodeName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>unicode_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Sets the unicode name of the prefix. The unicode name is an alternative to the short name that is preferred if unicode characters can be displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unicode_name</td><td>The new unicode name for the prefix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada42847734fb1c0d0312b8f0b6c32e64" name="ada42847734fb1c0d0312b8f0b6c32e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada42847734fb1c0d0312b8f0b6c32e64">&#9670;&nbsp;</a></span>shortName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Prefix::shortName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_long_if_no_short</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_unicode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the short name of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return_long_if_no_short</td><td>If the long name shall be returned if the prefix has not got a short name (if it is empty). </td></tr>
    <tr><td class="paramname">use_unicode</td><td>If a unicode version of the name is allowed and preferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The short name of the prefix. </dd></dl>

</div>
</div>
<a id="a2e3d9095de33a874a898b7218636be3a" name="a2e3d9095de33a874a898b7218636be3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3d9095de33a874a898b7218636be3a">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int Prefix::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns type, subclass, of the prefix. This can be PREFIX_DECIMAL for prefixes of the class <a class="el" href="classDecimalPrefix.html" title="A decimal (metric) prefix.">DecimalPrefix</a>, PREFIX_BINARY for <a class="el" href="classBinaryPrefix.html" title="A binary prefix.">BinaryPrefix</a>, or PREFIX_NUMBER for <a class="el" href="classNumberPrefix.html" title="A prefix with a free numerical value.">NumberPrefix</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The type of the prefix. </dd></dl>

<p>Implemented in <a class="el" href="classDecimalPrefix.html#ab860ba452c582edbafd026c58cb6f1e9">DecimalPrefix</a>, <a class="el" href="classBinaryPrefix.html#a1a200fd4dbf55302104306f40929fb5a">BinaryPrefix</a>, and <a class="el" href="classNumberPrefix.html#af7228bfa6a6058f58b404edaac1af549">NumberPrefix</a>.</p>

</div>
</div>
<a id="a5fa5234ff4a76ff19be3ca199607faba" name="a5fa5234ff4a76ff19be3ca199607faba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa5234ff4a76ff19be3ca199607faba">&#9670;&nbsp;</a></span>unicodeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string &amp; Prefix::unicodeName </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>return_short_if_no_uni</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns the unicode name of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">return_short_if_no_uni</td><td>If the short name shall be returned if the prefix has not got a unicode name (if it is empty). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The unicode name of the prefix. </dd></dl>

</div>
</div>
<a id="ae304214d9254a1e9e06d8ee2c6df09ab" name="ae304214d9254a1e9e06d8ee2c6df09ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae304214d9254a1e9e06d8ee2c6df09ab">&#9670;&nbsp;</a></span>value() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNumber.html">Number</a> Prefix::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the value of the prefix.</p>
<dl class="section return"><dt>Returns</dt><dd>The value of the prefix. </dd></dl>

<p>Implemented in <a class="el" href="classDecimalPrefix.html#a66dd7c2ae207e1a6ac6213caa84f87e4">DecimalPrefix</a>, <a class="el" href="classBinaryPrefix.html#adf79163230d0bb689b58477e6e4bd3be">BinaryPrefix</a>, and <a class="el" href="classNumberPrefix.html#a183f12382a98e53ce4ae6ddf712b1e15">NumberPrefix</a>.</p>

</div>
</div>
<a id="ae828e66c2fc5b58cc6cc6df5db15d2b2" name="ae828e66c2fc5b58cc6cc6df5db15d2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae828e66c2fc5b58cc6cc6df5db15d2b2">&#9670;&nbsp;</a></span>value() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNumber.html">Number</a> Prefix::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumber.html">Number</a> &amp;&#160;</td>
          <td class="paramname"><em>nexp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the value of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nexp</td><td>The power of the prefixed unit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the prefix. </dd></dl>

<p>Implemented in <a class="el" href="classDecimalPrefix.html#aa7826ccaf2953528e7e649d585fcbe17">DecimalPrefix</a>, <a class="el" href="classBinaryPrefix.html#ade4a15adf0b73502077c89b2cc51d531">BinaryPrefix</a>, and <a class="el" href="classNumberPrefix.html#abbc1a0ecc4929a2ae098befd39890111">NumberPrefix</a>.</p>

</div>
</div>
<a id="aa1eec8b3ac6266f3865d169c07d9e26d" name="aa1eec8b3ac6266f3865d169c07d9e26d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1eec8b3ac6266f3865d169c07d9e26d">&#9670;&nbsp;</a></span>value() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classNumber.html">Number</a> Prefix::value </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iexp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Returns the value of the prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iexp</td><td>The power of the prefixed unit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the prefix. </dd></dl>

<p>Implemented in <a class="el" href="classDecimalPrefix.html#a8727170084cd15b17eb330978d616872">DecimalPrefix</a>, <a class="el" href="classBinaryPrefix.html#a7d4e91f2addcc816fdc68441fa85943d">BinaryPrefix</a>, and <a class="el" href="classNumberPrefix.html#a41061cf96c0fc189616fc5a3bd2d0656">NumberPrefix</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/hanna/Utveckling/libqalculate/libqalculate/<a class="el" href="Prefix_8h.html">Prefix.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
